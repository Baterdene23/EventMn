import * as crypto from "crypto"
import * as bcrypt from "bcryptjs"
import nodemailer from "nodemailer"

import { prisma } from "@/lib/db/client"

// Type will be generated by Prisma after migration
// For now, define locally for type safety
export type OtpPurpose = "RESET_PASSWORD" | "LOGIN_2FA" | "VERIFY_EMAIL"

const OTP_EXPIRY_MINUTES = 10
const MAX_ATTEMPTS = 5
const BCRYPT_ROUNDS = 10

// ==========================================
// OTP Generation & Hashing
// ==========================================

/**
 * Generate a 6-digit OTP code
 */
export function generateOtpCode(): string {
	return crypto.randomInt(100000, 999999).toString()
}

/**
 * Hash OTP code for secure storage
 */
export async function hashOtpCode(code: string): Promise<string> {
	return bcrypt.hash(code, BCRYPT_ROUNDS)
}

/**
 * Verify OTP code against hash
 */
export async function verifyOtpCode(code: string, hash: string): Promise<boolean> {
	return bcrypt.compare(code, hash)
}

// ==========================================
// Email Transport
// ==========================================

function createTransport() {
	return nodemailer.createTransport({
		host: process.env.SMTP_HOST,
		port: Number(process.env.SMTP_PORT) || 587,
		secure: process.env.SMTP_SECURE === "true",
		auth: {
			user: process.env.SMTP_USER,
			pass: process.env.SMTP_PASS,
		},
	})
}

// ==========================================
// OTP Database Operations
// ==========================================

/**
 * Create and store a new OTP for the given email and purpose
 */
export async function createOtp(email: string, purpose: OtpPurpose): Promise<string> {
	const code = generateOtpCode()
	const codeHash = await hashOtpCode(code)
	const expiresAt = new Date(Date.now() + OTP_EXPIRY_MINUTES * 60 * 1000)

	// Invalidate any existing unused OTPs for this email+purpose
	await prisma.emailOtp.updateMany({
		where: {
			email: email.toLowerCase(),
			purpose,
			usedAt: null,
		},
		data: {
			usedAt: new Date(), // Mark as used to invalidate
		},
	})

	// Create new OTP
	await prisma.emailOtp.create({
		data: {
			email: email.toLowerCase(),
			purpose,
			codeHash,
			expiresAt,
		},
	})

	return code
}

/**
 * Verify OTP and mark as used if valid
 * Returns { valid: true } or { valid: false, error: string }
 */
export async function verifyOtp(
	email: string,
	purpose: OtpPurpose,
	code: string
): Promise<{ valid: boolean; error?: string }> {
	// Find the most recent unused OTP for this email+purpose
	const otp = await prisma.emailOtp.findFirst({
		where: {
			email: email.toLowerCase(),
			purpose,
			usedAt: null,
		},
		orderBy: { createdAt: "desc" },
	})

	if (!otp) {
		return { valid: false, error: "OTP олдсонгүй эсвэл хүчингүй болсон" }
	}

	// Check expiry
	if (otp.expiresAt < new Date()) {
		return { valid: false, error: "OTP-ийн хугацаа дууссан" }
	}

	// Check max attempts
	if (otp.attempts >= MAX_ATTEMPTS) {
		return { valid: false, error: "Хэт олон буруу оролдлого. Шинэ OTP авна уу" }
	}

	// Verify code
	const isValid = await verifyOtpCode(code, otp.codeHash)

	if (!isValid) {
		// Increment attempts
		await prisma.emailOtp.update({
			where: { id: otp.id },
			data: { attempts: { increment: 1 } },
		})
		return { valid: false, error: "Буруу OTP код" }
	}

	// Mark as used
	await prisma.emailOtp.update({
		where: { id: otp.id },
		data: { usedAt: new Date() },
	})

	return { valid: true }
}

// ==========================================
// Email Sending
// ==========================================

export async function sendOtpEmail(
	email: string,
	code: string,
	purpose: OtpPurpose
): Promise<{ success: boolean; error?: string }> {
	try {
		const transporter = createTransport()

		const subject = getEmailSubject(purpose)
		const html = getEmailHtml(code, purpose)

		await transporter.sendMail({
			from: process.env.SMTP_FROM || "noreply@eventmn.mn",
			to: email,
			subject,
			html,
		})

		return { success: true }
	} catch (error) {
		console.error("Failed to send OTP email:", error)
		return { success: false, error: "Имэйл илгээхэд алдаа гарлаа" }
	}
}

function getEmailSubject(purpose: OtpPurpose): string {
	switch (purpose) {
		case "RESET_PASSWORD":
			return "EventMN - Нууц үг сэргээх код"
		case "LOGIN_2FA":
			return "EventMN - Нэвтрэх баталгаажуулалтын код"
		case "VERIFY_EMAIL":
			return "EventMN - Имэйл баталгаажуулах код"
		default:
			return "EventMN - Таны баталгаажуулах код"
	}
}

function getEmailHtml(code: string, purpose: OtpPurpose): string {
	const purposeText = getPurposeText(purpose)

	return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; background-color: #f5f5f5;">
  <div style="max-width: 400px; margin: 0 auto; background: white; border-radius: 12px; padding: 32px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
    <h1 style="font-size: 24px; margin: 0 0 8px 0; color: #111;">EventMN</h1>
    <p style="color: #666; margin: 0 0 24px 0;">${purposeText}</p>
    
    <div style="background: #f0f0f0; border-radius: 8px; padding: 20px; text-align: center; margin-bottom: 24px;">
      <span style="font-size: 32px; font-weight: bold; letter-spacing: 8px; color: #111;">${code}</span>
    </div>
    
    <p style="color: #666; font-size: 14px; margin: 0;">
      Энэ код 10 минутын дотор хүчинтэй. Хэрэв та энэ хүсэлтийг илгээгээгүй бол энэ имэйлийг үл тоомсорлоно уу.
    </p>
  </div>
</body>
</html>
`
}

function getPurposeText(purpose: OtpPurpose): string {
	switch (purpose) {
		case "RESET_PASSWORD":
			return "Нууц үг сэргээхийн тулд доорх кодыг оруулна уу:"
		case "LOGIN_2FA":
			return "Нэвтрэхийн тулд доорх кодыг оруулна уу:"
		case "VERIFY_EMAIL":
			return "Имэйл хаягаа баталгаажуулахын тулд доорх кодыг оруулна уу:"
		default:
			return "Доорх кодыг оруулна уу:"
	}
}

// ==========================================
// Password Hashing (for reset-password)
// ==========================================

export async function hashPassword(password: string): Promise<string> {
	return bcrypt.hash(password, BCRYPT_ROUNDS)
}

export async function verifyPassword(password: string, hash: string): Promise<boolean> {
	return bcrypt.compare(password, hash)
}
